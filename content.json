{"meta":{"title":"浙江大学超算队","subtitle":"Zhejiang University Supercomputer Team","description":"Infinit Cores & Possibility.","author":"ZJU · SCT","url":"https://zjusct.github.io","root":"/"},"pages":[{"title":"关于世界大学生超级计算机竞赛(ASC\\ISC\\SC)","date":"2018-10-01T07:12:16.000Z","updated":"2019-05-31T15:04:27.522Z","comments":true,"path":"about/index.html","permalink":"https://zjusct.github.io/about/index.html","excerpt":"","text":"竞赛目的ASC超算竞赛旨在通过大赛的平台推动各国及地区间超算青年人才交流和培养，提升超算应用水平和研发能力，发挥超算的科技驱动力，促进科技与产业创新。吸引本科生参加超级计算机竞赛以培养学生在超算并行、高性能计算方面的动手实践能力，促进课程理论知识与实践能力的结合。 竞赛内容竞赛总共由数道题目组成, 每一道赛题都是对现代科学难题的挑战，需要考验参赛队伍的分析解决问题以及团队协同作战的综合能力。比赛要求每个队伍完成超级计算机集群的设计与搭建，要求选手必须要具备驾驭计算机软硬件操作系统的整体能力，还要在自搭建的集群计算机系统上完成面向前沿科技领域难题的科学应用软件的高性能优化，要具备程序并行优化编码能力。竞赛分为多个流程：理论方案、设计模型、实现、现场展示、答辩等。 奖项设置 ASC 超算竞赛： 总冠军、亚军各1 项，ePrize 奖1 项（季军），最高计算性能HPL 冠军，最佳应用创新奖，最佳应用奖，最佳呈现奖及一等奖若干 ISC/SC 超算竞赛： 总冠军一名，授予在整体算例以及现场呈现过程中得分最高的队伍。最高计算性能：HPL 单项冠军一名，授予HPL 比赛成绩最高的队伍。最受欢迎奖一名，授予比赛期间得到ISC 参会者投票最多的队伍。难度一样，规模比ASC稍小。 浙江大学历年成绩 ASC2014 世界大学生超级计算机竞赛一等奖 ASC2015 世界大学生超级计算机竞赛一等奖 ASC2016 世界大学生超级计算机竞赛一等奖 ASC2016 世界最高计算性能冠军奖 ASC2016 世界最高计算性能打破世界纪录 ASC2018 世界大学生超级计算机竞赛初赛第四名 决赛一等奖 超算队还开设短学期课程 超算团队与信息安全竞赛、系统设计能力竞赛、程序设计竞赛一起，共同推进以计算机系统能力为基础的人才培养改革与课程建设。超算基地近5 年来的人才培养与成果积累，参与申报2017 年“系统能力建设教学成果奖评比”项目，获浙江省教学成果一等奖。与ACM算法竞赛同为浙江大学世界级学科竞赛项目 拥有保研名额。"},{"title":"Contact Us!","date":"2018-12-08T12:42:52.000Z","updated":"2019-05-31T15:04:27.541Z","comments":true,"path":"contact/index.html","permalink":"https://zjusct.github.io/contact/index.html","excerpt":"","text":"Send your email and Join ZJUSCT now!window.location.href =\"mailto:jiongchiyu@zju.edu.cn\""},{"title":"Team Introduction","date":"2018-11-05T05:01:49.000Z","updated":"2019-05-31T15:04:27.542Z","comments":true,"path":"teamIntro/index.html","permalink":"https://zjusct.github.io/teamIntro/index.html","excerpt":"","text":"超算队指导老师介绍陈建海老师 陈建海，博士，浙江大学计算机学院。浙江大学计算机学院智能计算&amp;系统实验室（InCAS-LAB）区块链负责人，IEEE、ACM、CCF会员。研究领域：计算机体系结构领域，涉及云计算、虚拟化、区块链，擅长区块链系统性能与安全，虚拟计算系统性能优化与调度，高性能计算并行应用优化，近似算法与博弈论运用等。 负责区块链、高性能计算方面的重点研发项目子课题2项，参与完成多项云计算虚拟化相关的国家科技部支撑计划、国家基金以及企业合作项目。累计发表SCI/EI论文15篇，申请授权专利超过30项。 第44界世界技能大赛网站设计项目浙江省技术专家组组长，国家级裁判，带领浙江省队员获44界世界技能大赛全国选拔赛第四名。主持Designer项目获2018全球迅雷区块链应用开发大赛第一名。 沈钦仙老师 学校支持 设备介绍计算机学院超算竞赛基地 吸引本科生参加超级计算机竞赛以培养学生在超算并行、高性能计算方面的动手实践能力，促进课程理论知识与实践能力的结合 开设暑期超算集训短学期课程 学院提供超算竞赛基地，支持每年8万元经费 硬件强支撑：学校与学院支持建有13节点百万超算集群，含GPU\\MAC卡等异构设备 赞助与合作介绍 ASC2016 获英伟达硬件Tesla GPU K80 加速卡硬件赞助 ASC2018 获AMAX 赞助借用硬件Tesla GPU V100 8块 ······"}],"posts":[{"title":"生成式对抗网络_基础","slug":"GAN_Introduction","date":"2019-05-30T16:00:00.000Z","updated":"2019-05-31T15:25:27.713Z","comments":true,"path":"2019/05/31/GAN_Introduction/","link":"","permalink":"https://zjusct.github.io/2019/05/31/GAN_Introduction/","excerpt":"","text":"Reference : Machine Learning and having it deep and structured (2018,Spring) （李宏毅） Introduction of GAN生成式对抗网络（Generative Adversarial Network，GAN），是2014年被提出来的一种生成式深度学习网络技术。 由于在众多应用场合中的出色表现，近年来GAN的应用和研究已经成为一个非常热门的方向。 这篇文章将会对GAN做一个直观的介绍，帮助读者理解GAN的Basic Idea。 第一节中，我们将简单对机器学习的Basic Ideas做一个回顾。第二节和第三节会简单介绍一下什么是生成（Generation）。第四节和第五节会介绍两种生成模型。第六节我们将会看到GAN是如何结合这两种模型从而达到优秀的表现。 Review for ML在之前的文章（ 机器学习 / 卷积神经网络）中，我们介绍了一些机器学习（Machine Learning）的思想和例子。 简单回顾一下在这些文章中的讨论，我们知道，机器学习本质上就是一个映射拟合 : 在这个过程中，模型（Model）是一个函数，我们希望对它输入一个自变量x，能从它那里得到一个我们想要的输出y。以房价预测为例，我们希望告诉这个模型一些当前的经济，政治等社会环境，它能反馈一个房价数值。以图像分类为例，我们希望告诉这个模型一张图片，它能反馈给我们这张图片属于什么类别。 在最简单的形式中，我们用一个简单的线性模型（Linear Model） $w*x=y$ 来建模这个函数。高级一点，选择一个更复杂的核函数（另一种说法也可以称特征函数）的话，这个线性模型可以表达更加复杂的关系。再高级一点，把这些线性模型多层复合起来，形成神经网络（Neural Network），表达力就更强，而这个用深度神经网络来建模的方法自成一派，也就是所谓的深度学习（Deep Learning）。 而常常所说的训练数据（Training Data）无非就是从真实的世界中采样的一组（x，y）样本。训练（Training）则是让我们的模型从训练数据中学习x和y之间存在的某种规律的模式（Pattern），模型的参数在学习过程中不断调整，最后模型代表的函数尽可能的去模拟了真实世界中的映射关系。 这个学习过程又是怎样的呢？通常就是定义了一个损失函数（Loss Function），这个损失函数的值是基于模型预测出来的结果和我们采样出来的真实结果的差别。所谓学习其实就是最小化这个差别。因此，所谓的学习，本质上就是这个函数最优化问题的一种拟人化表达而已。 因此机器学习实际上就是给定一个训练数据集，产生一个预测函数。这个预测函数能对输入的x给出期望的y，简单的可以表示为这样： What Is Generation机器学习中，有很多种类型的任务，比如最简单的回归（Regression），分类（Classification）等。 它们是机器学习入门时肯定会接触的例子，常见的回归/分类任务比如：给定一张图片，输出一个标量或者向量描述这个图片的性质。 而生成（Generation）实际上就可以简单的理解为上述任务的一种逆向过程。给机器一张图片，它给你一个向量描述它的类别或者特征，似乎很无聊？那么如果给机器一个向量后，它给你生成一张图片(老婆)呢？ 这就是生成任务最直观最简单的例子。（除了生成图片以外，当然它也可以用来生成句子/音频等其它任何你能想到的东西，只要能保证可训练。） 如上图所示，只需要调整对生成器的输入向量，它就会相应的生成不同的图片。P2中增大了第一维的输入，生成的人物头发变长了；P3中改变向量倒数第二维的输入，人物头发变成了蓝色；P4中增大了向量的最后一维，生成的人像就变得笑口常开了。 Why Generation一个很自然的问题是：为什么我们需要生成？给我一个向量，我生成一张图片有什么用？ 如果只是给一个很枯燥的向量，让机器生成一张图片确实没啥用。但是如果再组合上其它的功能模块，这个技术可能会非常有用。 比如说，我们可以不从向量开始，而从一个句子开始。训练这样一个模型，自然语言先被转成向量编码，向量编码再被转成这个自然语言句子描述的画面。 又比如说，我们可以从图片中修改一部分区域，画出一个简单的草图，它就自动帮我们生成更加真实的修改内容。 你甚至还可以根据马云的脸的表情信息的编码生成一张小罗伯特·唐尼同样表情的脸，然后替换上去，产生真实的换脸效果。 生成，在某种意义上来说，是人工智能最有意义的任务。回归和分类这样的任务仅仅是去理解和识别我们熟知的对象，比如识别一句话是不是脏话，识别一张图片是不是猫。但是生成却是化腐朽为神奇，仅仅根据一些非常空洞的描述就自动生成了我们人所熟知的对象，这才是我们真正最想让人工智能为我们做的。仅仅是理解和识别，人工智能终究只是作为一种辅助工具。但是当它能创造的时候，它就翻身做了主人。 上图是一个向量生成图片的例子。向量按照一种顺序在逐渐变化，我们而可以看到第四行生成的人脸也在变化。惊人的是，它的生成竟然是一个连续的将脸变换一个朝向的过程。这说明，这个模型确实学到了这个人的脸的深刻特征，能根据向量的微调，对产生的结果也生成连贯一致的微调。 不只是绘画，当它还能生成语言，生成电影，生成代码，生成电路设计，生成科学理论时，它体现出来的智能性是非常让人震撼的。学习到对象/概念的深层次内涵，并且能够使用这些学到的知识去创造未知的东西，这是人工智能的究极目标之一。 Auto-encoderBasic Idea 上图是生成模型的一种基本模式，我们希望输入一个向量得到一个目标输出作为图形。 一个简单问题是，我们如何训练它？容易想到的是事先准备一堆向量和图片之间的映射对，让这个生成器学得某种映射模式，如下图所示： 但面临的一个现实问题是，用于训练的图片很容易得到，但是这个向量code如何得到？需要我们手工设置吗？对于一些大型的项目，这个向量一般维度很高，样例也很多，手工设置这些向量标签可操作性并不强。并且，如果设计的向量不好，也很难保证模型收敛。 自编码器在一定程度上解决了这个问题： 如图，自编码器接收一张图片作为输入，先丢入一个神经网络中产生一个编码作为输出（一个高维向量），这个产生的编码再被丢入另外一个神经网络，恢复成图片。我们希望恢复出来的图片尽可能和输入的图片相近，于是可以定义一个loss来衡量图片在这一次编码和解码过程中的损失，根据这个loss，再使用像梯度下降之类的方法，就可以调整encoder和decoder的参数，使得其尽可能减少损失。 在这样一个自编码，自解码的过程中，我们就既有了编码器和解码器。我们可以只对解码器输入向量，就能得到一个生成图。需要注意到的是，在这样一个自编码器模型中，code和image的映射完全是由模型生成的。模型会自动帮我们调优这个映射的划分。 PS : 这个code的长度是一个超参数，我们需要设定一个适合的编码长度。一方面，它的长度小于原图才能达到我们希望的提取特征的效果。另一方面，如果它的长度太小，可能无法容纳图片中必须的一些关键信息，导致无法还原。 Pros and Cons自动编码器的优点很显然，只需要给模型展示一些正例，它就能学到编码与图片之间的映射，非常易于训练和生成。 上面我们说了，我们在训练一个自编码器的时候，希望的是输出图片和输入图片尽可能的相近，减少损失。这个相似如何去衡量呢？一般采用的方法都是把图片当作高维向量处理，求两个向量之间距离的L1或者L2范数。这个范数就表征了两张图片之间的差别，而这样的衡量方式局限性很明显： 如上图所示，如果我们让机器生成了四个版本的“2”的图片。其中v1和v2与原图只差了一个像素点，v3和v4查了足足6个像素点。但是v1和v2破绽很明显，v1在尾巴上出现了一个孤立的橘色块，而v2在中间留了一块白出来，这都是不自然的。而v3和v4虽然像素点差距更大，但是其实只是尾巴和头分别拉长了一点罢了，这都是很正常的情况。所以，用这种标准训练出来的模型，它显然缺少一个大局观。只是机械的分别关注全局对象的每一个小组成部分，很难学到组成部分之间的关联。 DiscriminatorBasic Idea 评估器接收一个对象输入，产生一个标量输出。（其实就是一个回归问题）如上图所示，以生成图片的任务为例，一个评估器会评估机器生成的图片是否和人类作出来的图有一样的效果，根据生成质量，评估器会给出一个0~1的评分。 假设我们已经有了一个很好的评估器，我们也可以用拿它来生成图片。给定一个向量，我们通过一些事先构造的假设，将其可能对应的图片锁定在一个集合（可能会很大）中。图片生成就成为了在这个集合中枚举，筛选出一个得分最高的图片： Train一个实际的问题是，如何训练一个好的评估器？它怎么能分辨出哪些是画得好的，哪些是画得糟糕的？ 在网上，我们可以下载一大堆艺术家绘制的图片，他们都可以拿来作为正例，用来让模型学习什么是“好”图片。但是如果全都是正例，那么评估器将会收敛为一个恒输出1的常函数。所以，要训练一个评估器，面临的一个实际问题是：如何获得好的反例？ 如果反例的采样分布没有选好，那么模型对反例的识别能力也会很差。就会像上图那样，一个画得很一般的图片却获得了0.9的高分。 我们可以通过一个迭代算法来不断强化这个评估器： 如上图所示。一开始，我们可以随机生成一批反例，然后我们用当前的正例和反例训练出来一个评估器。评估器是个什么东西呢？它本质上也是一个定义在图片域上的函数。我们现在就从这个定义域上采集一批评分很高的图片来作为反例，用新的反例结合之前的正例重新训练，得到下一个版本的评估器。最后不断迭代。 上图是一个迭代过程的示意图，绿色为真实图片的分布域，蓝色为生成的效果糟糕的图片的分布域，红色曲线是我们的评估函数。在第一轮的训练中，真实域的函数估值会被拉高，我们随机生成那些噪音图片所在的域的股指会被压低。但是这个估值函数可能还不够，它可能没有发现其它很糟糕的图片的分布域，给了它们很高的估值，我们称为“虚高”。所以我们会进行第二轮训练，第二轮中用到的反例是从第一轮训练出来的估值函数中采样的估值高的点，那些“虚高”的点因为被作为反例被压低，而那些本来就该得分高的点即使被采样为反例，但是因为有同区域的正例在支撑，所以这一区域的估值不会被压低。最后，多轮迭代后，那些虚高的点就会逐渐被压平，只有正例分布的区域还依旧坚挺。此时我们就认为得到的评估函数是优秀的。 这就像是制定一部法律。我们希望人们的行为被约束在一个我们预先定义的可接受的范围内。但是法律有漏洞，总有人钻空子，在制定者期望之外的区域获得很高的收益。法律制定者就会锁定这些突出的领域专门指定新的条令来打击。经过不断的实践和修订，这部法律也就完善起来。 Pros and Cons估值器的优点正好弥补了自动编码器的缺点。自动编码器是一个Button Up的模型，它根据编码对每一个像素点单独生成，组成一个完整的更高层的结果，这样的Button Up模型很难学到不同组成部分之间的关联。而估值器是一个Top Down模型，它直接获得正常图片作为输入，用全连接网络或者卷积网络很容易学习图片中的一些局部以及全局特征。 但是缺点也很明显。从上面看到，我们发现评估器很依赖于一个argmax的计算。如果要用它来生成模型，我们需要在一个域上找到得分最高的候选图。如果要用迭代法来训练一个评估器，我们也需要在当前的评估函数域采样估值高的点来作为新的反例。然而这个argmax怎么算呢？很多用discriminator来做生成的，都要事先做一些不准确的假设，根据这些假设对不同的输入向量在图片域中划分一个候选域，在这个可行域上做argmax。并且有的时候需要大量的枚举，非常耗时。并且要训练评估器也不容易，光有正例还不行，还得自己去合理的生成反例。 所以，显而易见，评估器虽然有了自编码器难以学得的全局观，但是却没了自编码器那种易于生成结果的特性。 GAN讨论了这么多，终于轮到主人公GAN登场了。 前面我们先讨论了Auto-encoder和Discriminator，分别介绍了用它们来做生成的基本想法。在讨论中，我们已经意识到了：Auto-encoder很容易产生生成图像，但是由于是button-up的模型，根据编码分别对每一个像素点预测，很难学得像素点之间的关系；Discriminator很容易学得图像中一些局部和全局的特征细节，可以很好的处理像素点之间的correlation，但是其主要能力还是在做评估上，在生成方面它还是缺乏一个有效的生成手段。 GAN集成了这两个方法：一方面，GAN使用一个类似Auto-encoder结构的Generator来生成图像，另一方面它用一个Discriminator来评估生成图片的质量。 Basic Idea考虑这样的一个过程： 一开始我们已经有了一个generator和discriminator，它们的参数都是随机设置的。generator生成的图片很糟糕，discriminator也无法判别什么图片是好的。 然后我们可以以一个适当的概率分布随机向这个generator中输入一组向量，然后得到一堆生成的图片，用这些图片作为反例，用艺术家绘制的图片作为正例训练discriminator。这轮训练后，得到的discriminator的能力得到了提升，能够学会给一些好的图片打高分，给一些差的图片打低分。 这之后，我们再固定这个discriminator的参数。此时如果我们给generator输入一个向量，再把它产生的图片送入discriminator中，我们会得到一个反馈的分数。这个反馈分数就可以作为LOSS，我们根据LOSS FUNCTION的梯度调整generator的参数，使得它尽可能产生可以骗过这个版本的discriminator，从它手下得到一个高分。这轮训练后，得到的generator的能力也得到了提升，能够产生一些像样的图片了。 然后我们又重复上面的过程，强化discriminator，discriminator强化后再强化generator。。。可以期望的是，多轮迭代后，我们的generator和discriminator都可以变得很强。 上图很好的从生物进化的角度很好的揭示了GAN的哲学。一开始蝴蝶颜色五颜六色的，停在树上的时候，捕食它的鸟根据颜色是否是棕色来区分它和叶子。在这个过程中，那些五颜六色的蝴蝶被淘汰了，棕色的蝴蝶脱颖而出，成功骗过了初代鸟。但是那些被骗过的初代鸟也会被淘汰，于是鸟也在这个过程中进化，学会了通过判别是否有叶脉来寻找猎物。而蝴蝶在这一过程中再次进化，成为了枯叶蝶。。。这是自然界中经典的良性竞争，互相强化的例子。而Generative Adversarial Network中的“Adversarial”也就是这样来的。在GAN中，我们让一个generator和一个discriminator互相对抗，generator努力的生成逼真的图片试图骗过discriminator，discriminator努力强化自己的辨别能力对抗generator的欺骗。模型的学习就是在两者的对抗之中互相强化而完成的。 Algorithm 上图是GAN的基本训练模式。$\\theta_d$ 和 $\\theta_g$ 分别是Discriminator和Generator的参数，一开始是随意初始化的。 每一轮中： 首先从数据库中采样m个真实样本${x_i}$，再让Generator随机生成m个虚假样本${\\hat{x_i}}$。 定义 $V=\\frac{1}{m}[;\\Sigma_{i=1}^{m}logD(x_i)+\\Sigma_{i=1}^{m}log(1-D(\\hat{x}_i));]$ 真实样本得分越高，虚假样本得分越低，这个V的值越大。于是我们只需要通过梯度上升法，最大化这个V，我们的Discriminator就能尽可能的对真实样本给出高分，尽可能的给虚假样本给出低分。这实际上就是完成了一个对Discriminator的强化。 在这之后，我们再取样m个随机向量${z_i}$，丢入Generator，再把生成的结果给Discriminator评估。 定义$V=\\frac{1}{m}\\Sigma_{i=1}^mlog(D(G(z_i)))$ 同样的，我们希望最大化这个V值，使得产生的结果尽可能骗过Discriminator。将V值对 $\\theta_g $ 求偏导，使用梯度上升来最大化这个V，从而实现对Generator的调优。 Comparision在GAN的设计中，我们可以看到其明显优于Auto-encoder和Discriminator的地方。Auto-encoder生成之后，缺乏一个强大评估反馈，简单的采用原图和恢复生成图的差向量范数来评估，无法考虑到各个component之间的correlation，缺乏一个大局观。Discriminator虽然能对图片产生很深的特征理解，但是缺少一个高效准确的proposal手段，训练时它非常依赖于反例的生成，生成时又需要选择一个候选区域来执行argmax，这都不是容易解决的问题。 GAN将这两者的特性做了一个结合。虽然还是采用button-up的生成方式，根据向量对每一个像素点单独生成，但是多了一个up-down评估模式的discriminator来对生成内容进行更加细致的评估反馈，从而generator能得到更好的训练指引。另一方面，由于有了一个更加强大的generator，训练discriminator时，能获得质量更高的反例，从而discriminator也能得到更好的训练。","categories":[],"tags":[{"name":"AI","slug":"AI","permalink":"https://zjusct.github.io/tags/AI/"}],"author":"漆翔宇"},{"title":"基于0-1乘性噪声的朴素图片降噪","slug":"Image-Restoration-SimpleVersion","date":"2019-05-10T16:00:00.000Z","updated":"2019-05-31T15:04:27.426Z","comments":true,"path":"2019/05/11/Image-Restoration-SimpleVersion/","link":"","permalink":"https://zjusct.github.io/2019/05/11/Image-Restoration-SimpleVersion/","excerpt":"项目内容给定3张受损图像，尝试恢复他们的原始图像。 原始图像包含1张黑白图像（A.png）和2张彩色图像（B.png, C.png）。 受损图像$X$是由原始图像$I \\in R ^ { H * W * C }$添加了不同噪声遮罩$M \\in R ^ { H * W * C }$得到的$x=I \\odot m$，其中$ \\odot $是逐元素相乘。 噪声遮罩仅包含{0,1}值。对应原图（A/B/C）的噪声遮罩的每行分别用0.8/0.4/0.6的噪声比率产生的，即噪声遮罩每个通道每行80%/40%/60%的像素值为0，其他为1。 评估误差为恢复图像与原始图像向量化后的差向量的2-范数，此误差越小越好。","text":"项目内容给定3张受损图像，尝试恢复他们的原始图像。 原始图像包含1张黑白图像（A.png）和2张彩色图像（B.png, C.png）。 受损图像$X$是由原始图像$I \\in R ^ { H * W * C }$添加了不同噪声遮罩$M \\in R ^ { H * W * C }$得到的$x=I \\odot m$，其中$ \\odot $是逐元素相乘。 噪声遮罩仅包含{0,1}值。对应原图（A/B/C）的噪声遮罩的每行分别用0.8/0.4/0.6的噪声比率产生的，即噪声遮罩每个通道每行80%/40%/60%的像素值为0，其他为1。 评估误差为恢复图像与原始图像向量化后的差向量的2-范数，此误差越小越好。 实现介绍 核心思想由于图片的像素点在空间上满足局部相似的特征，相邻的像素点通道值变化往往是平滑且有一定规则的。因此，我们可以用一个模型来拟合像素点通道值在空间上的关系。具体实现中，我们将图片切割成若干个小矩形块，然后使用一个二维线性回归模型来回归每个小矩形块中位置和像素通道值的函数关系。为了使结果更加平滑和可靠，我们采用了高斯函数作为基函数。 高斯函数当我们对一个 ss * ss 的像素矩阵块做回归的时候，我们要把所有没有被噪音损坏的点都提取出来。点位置用一个高斯核函数处理，这样原来的点坐标(x,y)就被转换成了$(e^{-\\frac{(x-mid)^2}{2}},e^{-\\frac{(y-mid)^2}{2}})$，在特征空间中用来刻画这个点与矩阵块中心的距离。这样，我们实际要回归的就是点心距与像素通道值的关系。 这样做，主要是因为我们的局部性原理本身就是不带方向性的，所谓的局部性就是指临近的点存在某种平滑的变化关系。使用这样一个衡量距离的核函数，可以使得我们的回归结果更加平滑： 上图左边是用坐标直接回归，右图是坐标经过高斯核处理后回归的结果。可以看到左边有大量的不平滑的交错的黑白点，看起来很“脏”。右边由于采用了高斯函数处理过的表征距离关系的核函数，结果更加平滑，清晰。 CODE : 训练提取完特征后的数据点拟合，就是一个简单的线性回归任务而已，我们采用最小二乘法回归。$$Loss = \\frac {\\Sigma_{i=0}^n(y_i-\\phi(x_i) * w^T)^2}{n}=\\frac{\\Sigma_{i=1}^{n}Loss_i}{n}$$使用随机梯度下降来最优化损失函数：$$w\\leftarrow w-\\eta * \\triangledown Loss_i=w+2\\eta(y_i-\\phi(x_i) * w^T) * \\phi(x_i)$$具体实现中，我们取步长=0.005，进行100轮随机梯度下降。 CODE : ​ 迭代降噪我们前面提到了，我们要把图片切成若干个小矩形块，对每个小矩形块分别进行回归，那么这个小矩形块的尺寸取多少比较合适呢？ 我们先取ss=2尝试一下： 噪音为0.8的时候，我们可以看到，如果取一个2*2的块，期望其中没损坏的通道只有0.8个，所以势必有大量的矩阵块里面都是全损坏的，这会使得一些全损坏的块得不到修复，产生大量的黑点。 直接取ss=5： 显然，黑块的数量变少了，但是实际上图片给人的颗粒赶很明显，更像是一堆模糊的马赛克拼图拼凑而成的。 我们的解决办法是先取ss=2，对图片做恢复，然后将恢复的图像再用更大的ss来恢复。 下面是用ss={2，3，4，5}迭代恢复四次的过程： 可以看到黑点逐渐被消除，并且最后经过ss=5的回归后得到的结果在视觉效果上明显优于直接用ss=5进行回归。这种想法本质上是一种贪心算法。先将损失密度小的局部块恢复好，再充分利用之前修复出来的信息将损失密度更大的块修复。 实验结果A （noise rate = 0.8） B（noise rate = 0.4） C（noise rate = 0.6） D（根据原图自己生成，测试迭代过程中损失的减少） 潜在的优化展望 由于每个块的修复是独立的，可以考虑使用CPU多线程计算或者在GPU上用CUDA进行并行优化，加速整个修复过程。 使用更复杂的网络来拟合。 使用马尔科夫随机场的方法来做图像降噪。","categories":[],"tags":[{"name":"AI","slug":"AI","permalink":"https://zjusct.github.io/tags/AI/"}],"author":"漆翔宇"},{"title":"Virtual Memory and TLB","slug":"Virtual-Memory-and-TLB","date":"2019-03-31T06:05:11.000Z","updated":"2019-05-31T15:04:27.472Z","comments":true,"path":"2019/03/31/Virtual-Memory-and-TLB/","link":"","permalink":"https://zjusct.github.io/2019/03/31/Virtual-Memory-and-TLB/","excerpt":"虚拟地址空间x86 CPU 的地址总选宽度为32位，理论寻址上限为4GB。而虚拟地址空间的大小就是4GB，占满总线，且空间中的每一个字节分配一个虚拟地址 其中高2G0x80000000 ~ 0xFFFFFFFF为内和空间，由操作系统调用； 低2G0x00000000 ~ 0x7FFFFFFF为用户空间，由用户使用。 在系统中运行的每一个进程都独自拥有一个虚拟空间，进城之间的虚拟空间不共用。","text":"虚拟地址空间x86 CPU 的地址总选宽度为32位，理论寻址上限为4GB。而虚拟地址空间的大小就是4GB，占满总线，且空间中的每一个字节分配一个虚拟地址 其中高2G0x80000000 ~ 0xFFFFFFFF为内和空间，由操作系统调用； 低2G0x00000000 ~ 0x7FFFFFFF为用户空间，由用户使用。 在系统中运行的每一个进程都独自拥有一个虚拟空间，进城之间的虚拟空间不共用。 虚拟地址空间是一种通过机制映射出来的空间，与实际物理空间大小无必然联系，在x86保护模式下，无论计算及实际主存是512MB还是8GB，虚拟地址空间总是4GB，这是由CPU和操作系统的宽度决定的，即： CPU地址总线宽度 → 物理地址范围CPU的ALU宽度 → 操作系统位数 → 虚拟地址范围 虚拟内存虚拟地址空间 = 主存 + 虚拟内存(交换空间 Swap Space) 虚拟内存：将硬盘的一部分作为存储器使用，来扩充物理内存。 利用了自动覆盖、交换技术。内存中存不下、暂时不用的内容会存在硬盘中。 Assume: 32位操作系统，32位寻址总线宽度 → 4G线性空间 保护模式下的进程运行虚拟地址空间是硬件行为，CPU自动完成(同时与操作系统协作)虚拟地址到物理地址(可能差熬过实际内存，这样会产生一个异常中断，揭晓来有操作系统处理(如从虚拟内存中调出对应的页框内容))。 所以，一个程序若运行在保护模式下，其汇编级、机器语言级的寻址都是用的虚拟地址，即在一般的编程中不会接触到物理一层。 在进程被加载时，系统为进程建立唯一的数据结构进程控制块(PCB = Process Control Block)，直至进程结束。 PCB中描述了该进程的现状以及控制运行的全部信息，有了PCB，一个进程才可以在保护模式下和其他进程一起被并发地运行起来，操作系统通过PCB对进程进行控制。 PCB中的程序ID(PID(unix、linux)、句柄(windows))是进程的唯一标识；PCB中的一个指针指向 页表 ，这些都与地址转化有关。 地址转化地址转化的全过程可以用以下这张图来概括： 以下是具体步骤介绍。 1. 逻辑地址 → 线性地址 (段式内存管理，Intel早期策略的保留) 段内偏移地址(32位) 段选择符：16位长的序列，是索引值，定位段描述符；结构： 高13位为表内索引号 —— 但注意由于GDT第一项留空，所以索引要先加1； 而2位为TI表指示器，0是指GDT，1是指LDT； 0、1位是RPL请求者特权级，00最高，11最低 —— 在x86保护模式下修改寄存器是系统之灵，必须有对应的权限才能修改(当前执行权限和段寄存器中(被修改的)的RPL均不低于目标段的RPL) 段描述符：8x8=64位长的结构，用来描述一个段的各种属性。结构： 0、1字节+6字节低4位(20位) 段边界/段长度：最大1MB或者4G(看粒度位的单位) 2、3、4、7字节(32位) 段基址：4G线性地址的任意位置(不一定非要被16整除) 6、7字节的奇怪设计是为了兼容80286(24位地址总线) 剩下的那些是段属性，详见20180819143434 段描述表：多任务操作系统中，含有多个任务，而每个人物都有多个段，其段描述符存于段描述表中。IA-32处理器有3个段描述表：GDT、LDT和IDT。 GDT(Global Descripter Table) 全局段描述符表：一个系统一般只有一个GDT，含有每一个任务都可以访问的段；通常包含操作系统所使用的代码段、数据段和堆栈段，GDT同时包含各进程LDT数据段项，以及进程间通讯所需要的段。GDTR是CPU提供的寄存器，存储GDT的位置和边界；在32位模式下RGDT有48位长(高32位基地址+低16位边界)，在32e模式下有80位长(高64位基地址+低16位边界)。GDT的第一个表项留空不用，是空描述符，所以索引号要加1。GDT最多128项。 LDT(Local Descripter Table) 局部段描述符表：16位长，属于某个进程。一个进程一个LDT，对应有RLDT寄存器，进程切换时RLDT改变。RLDT和RGDT不一样，RLDT是一个索引值而不是实际指向，指向GDT中某一个LDT描述项。所以如果要获取LDT中的某一项，先要访问GDT找到对应LDT，再找到LDT中的一项。编译程序时，程序内赋予了虚拟页号。在程序运行时，通过对应LDT转译成物理地址。故虚拟页号是局部性的、不同进程的页号会有冲突。LDT没有空选择子。 IDT(Interrupt Descripter Table) 中断段描述符表；一个系统一般也只有一个。 以下这个图能做一点解释： 2. 线性地址 → 物理地址 (页式内存管理)这一步由CPU的页式管理单元来负责转换。——MMU(内存管理单元)。 线性地址可以拆分为三部分(或者两部分)： 页(Page)：线性地址被划分为大小一致的若干内存区域，其对应映射到大小相同的与物理空间区域页框(Frame)上。这个映射不一定是连贯而有序的。 CR3：页目录基址寄存器。对于每一个进程，CR3的内容不同(有点像RLDT)，页目录基址也不同，线性地址-物理地址的映射也不同。 页目录：占用一个4kb的内存页，最多存储1024个页目录表项(PDE)，一个PDE有4字节。在没启用PAE时，有两种PDE，规格不同。 页目录表项(PDE)：每个程序有多个页表，即拥有多个PDE。PDE的结构如下：12~31位(20位)表示页表起始物理地址的高20位(页表基址低12位为0，即一定以4kb对齐)。 页表：一个页表占4kb的内存页，最多存储1024个页表项(PTE)，一个PTE是4字节。页表的基址是4kb对齐的，低12位是0。 采用对页表项的二级管理模式(也目录→页表→页)能够节约空间。因为不存在的页表就可以不分配空间，并且对于Windows来说只有一级页表才会存在主存中，二级可以存在辅存中——不过Linux中它们都常驻主存。 一些CPU会提供更多级的架构，如三级、四级。Linux中，有对应的高层次抽象，提供了一个四层页管理架构：把中间的某几个定为长度为0，就可以调整架构级数。如“四化二”：某地址0x08147258，对应的PUD、PMD里只有一个表项为PUD→PMD，PMD→PT；划分的时候，PGD=0000100000，PUD=PMD=0，PT=0101000111. 3. TLB (转换检测缓冲区、快表、转译后被缓冲区)处理器中，一个具有并行朝赵能力的特殊高速缓存器，存储最近访问过的一些页表项(时空局部性原理，减少页映射的内存访问次数)。 TLB较贵，通常能够存放16~512个页表项。 TLB命中：直接取出对应的页表项 TLB缺失：先淘汰TLB中的某一项(TLB替换策略，一些算法，可以由硬件或软件来实现) 硬件处理TLB Miss：CPU会遍历页表，找到正确的PTE；如果没有找到，CPU就会发起一个页错误并将控制权交给操作系统。 软件处理TLB Miss：CPU直接发出未命中错误，让操作系统来处理。 脏记录：当TLB中某个PTE项失效(如切换进程、进程退出、虚拟页换出到磁盘)，PTE标记为不存在，此时映射已经不成立了。操作系统要保证即时刷新掉这些脏记录，不同的CPU有不同的刷新TLB方法，但每次都完全刷新TLB会很慢，所以现在有一些策略，扩展对一个PTE的描述(如针对某个进程、空间的标识，如果目前进程与PTE相关，就会忽略掉)，这样可以让多个进程同时共存TLB Linux 段式管理Linux似乎没有理会Intel的那一套段的机制，而是做了一个高级的抽象。Linux对所有的进程使用了相同的段来对指令和数据寻址，让每个段寄存器都指向同一个段描述符，让这个段描述符的基址为0，长度为4G。即用这种方式略去了段式内存管理。对应多有用户代码段、用户数据段、内核代码段和内核数据段。可以在segment.h中看到，四种段对应的段基址都是0，这就是“平坦内存模型”，这样就有段内偏移地址=逻辑地址 且，四种段对应的都为GDT。即Linux大多数情况都不使用LDT，除非使用wine等Windows防真程序。 Linux 0.11中每个进程划分64MB的虚拟内存空间。故逻辑地址范围为0~0x4000000","categories":[],"tags":[{"name":"Tech","slug":"Tech","permalink":"https://zjusct.github.io/tags/Tech/"},{"name":"Operating System","slug":"Operating-System","permalink":"https://zjusct.github.io/tags/Operating-System/"}],"author":"王克"},{"title":"如何在墙内快速部署CentOS 7的MySQL","slug":"Install-MySQL-on-CentOS7-Inside-GFW","date":"2019-03-31T02:45:19.000Z","updated":"2019-05-31T15:04:27.470Z","comments":true,"path":"2019/03/31/Install-MySQL-on-CentOS7-Inside-GFW/","link":"","permalink":"https://zjusct.github.io/2019/03/31/Install-MySQL-on-CentOS7-Inside-GFW/","excerpt":"MySQL 被 Oracle 收购后，CentOS 的镜像仓库中提供的默认的数据库也变为了 MariaDB，所以默认没有 MySQL ，需要手动安装。 其实安装 MySQL 也并不是一件很难的事情，但是由于一些实际存在的问题(比如某墙)，让默认通过 yum 安装 MySQL 的速度太慢。这里提出一种可行的方案来快速部署 MySQL ，此方案同样适用于其他 rpm 包软件的手动安装。 本文实际在讲的是，如何利用各种手段，加速和改善yum的安装过程。","text":"MySQL 被 Oracle 收购后，CentOS 的镜像仓库中提供的默认的数据库也变为了 MariaDB，所以默认没有 MySQL ，需要手动安装。 其实安装 MySQL 也并不是一件很难的事情，但是由于一些实际存在的问题(比如某墙)，让默认通过 yum 安装 MySQL 的速度太慢。这里提出一种可行的方案来快速部署 MySQL ，此方案同样适用于其他 rpm 包软件的手动安装。 本文实际在讲的是，如何利用各种手段，加速和改善yum的安装过程。 传统方案……慢到怀疑人生根据官方指南，我们执行如下命令： 123456# 下载源wget \"https://dev.mysql.com/get/mysql80-community-release-el7-2.noarch.rpm\"# 安装源sudo rpm -ivh mysql80-community-release-el7-2.noarch.rpm# 检查源是否成功安装sudo yum repolist enabled | grep \"mysql80-community*\" 接下来就是正常的安装步骤： 1sudo yum install mysql-community-server mysql 但是由于一些原因，下载速度基本是几Byte/s，MySQL 服务器的大小(加上依赖服务)差不多有600MB，这种方法基本不可取。手头没有特别好的而且很新的软件源，就打算手动安装。 手动安装法首先依然需要下载并安装官方源。 1yum install mysql-community-server 利用该命令我们可以获取一些 MySQl Server 以来安装顺序及其版本： 1234567891011121314================================================================================================= Package Arch Version Repository Size=================================================================================================Reinstalling: mysql-community-client x86_64 8.0.15-1.el7 mysql80-community 25 M mysql-community-libs x86_64 8.0.15-1.el7 mysql80-community 2 M mysql-community-common x86_64 8.0.15-1.el7 mysql80-community 570 K mysql-community-server x86_64 8.0.15-1.el7 mysql80-community 360 MTransaction Summary================================================================================================= 解压并分析rpm源包： 12rpm2cpio mysql80-community-release-el7-2.noarch.rpm | cpio -divvim /etc/yum.repos.d/mysql-community.repo 从中我们可以找到对应版本的网络路径为http://repo.mysql.com/yum/mysql-8.0-community/el/7/x86_64/。 打开该地址，找到对应的几个安装包： mysql-community-client-8.0.15-1.el7.x86_64.rpm mysql-community-libs-8.0.15-1.el7.x86_64.rpm mysql-community-common-8.0.15-1.el7.x86_64.rpm mysql-community-server-8.0.15-1.el7.x86_64.rpm 使用某种下载工具(我使用的是迅雷)下载，然后使用scp指令上传到服务器上： 1234scp mysql-community-client-8.0.15-1.el7.x86_64.rpm xxx@xx.xx.xx.xx:/root/mysql-community-client-8.0.15-1.el7.x86_64.rpmscp mysql-community-libs-8.0.15-1.el7.x86_64.rpm xxx@xx.xx.xx.xx:/root/mysql-community-libs-8.0.15-1.el7.x86_64.rpmscp mysql-community-common-8.0.15-1.el7.x86_64.rpm xxx@xx.xx.xx.xx:/root/mysql-community-common-8.0.15-1.el7.x86_64.rpmscp mysql-community-server-8.0.15-1.el7.x86_64.rpm xxx@xx.xx.xx.xx:/root/mysql-community-server-8.0.15-1.el7.x86_64.rpm 按照先后顺序依次执行yum本地安装： 123456sudo yum localinstall mysql-community-common-8.0.15-1.el7.x86_64.rpmsudo yum localinstall mysql-community-libs-8.0.15-1.el7.x86_64.rpmsudo yum localinstall mysql-community-client-8.0.15-1.el7.x86_64.rpmsudo yum localinstall mysql-community-server-8.0.15-1.el7.x86_64.rpmsudo yum -y install mysql 安装成功，启动并测试服务： 12systemctl start mysqld.servicesystemctl status mysqld.service 找出默认密码： 1grep &quot;password&quot; /var/log/mysqld.log &gt;&gt; defalut_mysql_passwd.txt","categories":[],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://zjusct.github.io/tags/MySQL/"},{"name":"CentOS","slug":"CentOS","permalink":"https://zjusct.github.io/tags/CentOS/"}],"author":"王克"},{"title":"BP算法","slug":"bp","date":"2018-12-24T13:03:59.000Z","updated":"2019-05-31T15:04:27.488Z","comments":true,"path":"2018/12/24/bp/","link":"","permalink":"https://zjusct.github.io/2018/12/24/bp/","excerpt":"本文探讨BP算法。","text":"本文探讨BP算法。 Feed forward neural network and back propagation1. Neuron structure 上图是一种典型的神经元结构，$x_n$是神经元的输入，将输入加权求和后再通过激活函数即可得到此神经元的输出：$$t = \\sum_{i=1}^{n}{w_ix_i} + b$$$$a = f(t)$$ 为计算方便，可将偏置$b$提到求和符号里面，相当于加入一个恒为1的输入值，对应的权重为$b$：$$t = \\sum_{i=0}^{n}{w_ix_i},(x_0 = 1, w_0 = b)$$$$a = f(t)$$此即为上图神经元结构对应的表达式 常用的激活函数有sigmoid, ReLU, tanh等。 2. Network structure 这是一个简单的3层网络，输入层有3个输入值，隐藏层包含3个隐藏神经元，最后是两个输出值隐藏层神经元的前向计算过程： $$z_i^{l} = \\sum_{i=0}^{n}w_{ij}^{l}x_j, (x_0 = 1, w_0 = b)$$ $$a_i^l = f(z_i^l)$$ $l$表示第几层。 这个网络的抽象数学表达式为：$$F(x) = f_3(f_2(x * W_2 + b_2) * W_3 + b_3)$$ 事实上，深度神经网络一般都能够抽象为一个复合的非线性多元函数，有多少隐藏层就有多少层复合函数：$$F(x) = f_n\\left(\\dots f_3(f_2(f_1(x) * w_1 + b_1) * w_2 + b_2)\\dots\\right)$$ 3. LossLoss，即损失，用来衡量神经网络的输出值与实际值的误差，对于不同的问题，通常会定义不同的loss函数 回归问题常用的均方误差：$$MSE = \\frac{1}{n}\\sum_{i=1}^{n}(Y - f(x))^2$$$Y$为实际值，$f(x)$为网络预测值 分类问题常用的交叉熵(m类)：$$L = \\sum_{k=1}^{n}\\sum_{i=1}^{m}l_{ki}log(p_{ki})$$$l_{ki}$表示第k个样本实际是否属于第i类（0，1编码），$p_{ki}$表示第k个样本属于第i类的概率值 特别地，二分类问题的交叉熵损失函数形式为：$$L = \\sum_{i=1}^{n}[y_ilog(p_i) + (1 - y_i)log(1 - p_i)]$$$y_i$为第i个样本所属类别，$p_i$为第i个样本属于$y_i$类的概率 4. Back propagationBP 是用来将loss反向传播的算法，用来调整网络中神经元间连接的权重和偏置，整个训练的过程就是：前向计算网络输出-&gt;;根据当前网络输出计算loss-&gt;BP算法反向传播loss调整网络参数，不断循环这样的三步直到loss达到最小或达到指定停止条件 BP算法的本质是求导的链式法则，对于上面的三层网络，假设其损失函数为$C$，激活函数为$\\sigma$，第$l$第$i$个神经元的输入为$z_i^{(l)}$，输出为$a_i^{(l)}$ 则通过梯度下降来更新权值和偏置的公式如下：$$W_{ij}^{(l)} = W_{ij}^{(l)} - \\eta\\frac{\\partial}{\\partial W_{ij}^{(l)}}C\\tag1$$$$b_{i}^{(l)} = b_{i}^{(l)} - \\eta\\frac{\\partial}{\\partial b_{i}^{(l)}}C\\tag2$$ $W_{ij}^{(l)}$表示第$l$层第$i$个神经元与第$l - 1$层第$j$个神经元连接的权值，$b_i^{(l)}$表示第$l$层第$i$个神经元的偏置 $\\eta$表示学习率 由更新公式可见主要问题在于求解损失函数关于权值和偏置的偏导数 第$l$层第$i$个神经元的输入$z_i^{(l)}$为：$$z_i^{(l)} = \\sum_{j=1}^{n^{(l-1)}}{W_{ij}^{(l)}a_j^{(l-1)}} + b_i^{l}\\tag3$$ 则更新公式中偏导项可化为: $$\\frac{\\partial}{\\partial W_{ij}^{(l)}}C = \\frac{\\partial C}{\\partial z_i^{(l)}} \\bullet \\frac{\\partial z_i^{(l)}}{\\partial W_{ij}^{(l)}} = \\frac{\\partial C}{\\partial z_i^{(l)}} \\bullet a_i^{(l-1)}\\tag4$$ $$\\frac{\\partial}{\\partial b_{i}^{(l)}}C = \\frac{\\partial C}{\\partial z_i^{(l)}} \\bullet \\frac{\\partial z_i^{(l)}}{\\partial b_{i}^{(l)}} = \\frac{\\partial C}{\\partial z_i^{(l)}}\\tag5$$ 定义 $$\\delta_i^{(l)} = \\frac{\\partial}{\\partial z_i^{(l)}}C\\tag6$$ 现在问题转化为求解$\\delta_i^{(l)}$，对第$l$层第$j$个神经元有：$$\\delta_j^{(l)} = \\frac{\\partial C}{\\partial z_j^{(l)}} = \\sum_{i=1}^{n^{(l+1)}}\\frac{\\partial C}{\\partial z_i^{(l+1)}} \\bullet \\frac{\\partial z_i^{(l+1)}}{\\partial a_j^{(l)}} \\bullet \\frac{\\partial a_j^{(l)}}{\\partial z_j^{(l)}} \\=\\sum_{i=1}^{n^{(l+1)}}\\delta_i^{(l+1)} \\bullet \\frac{\\partial(W_{ij}^{l+1} + b_i^{(l+1)})}{\\partial a_j^{(l)}} \\bullet \\sigma^\\prime(z_j^{(l)})\\=\\sum_{i=1}^{n^{(l+1)}}\\delta_i^{(l+1)} \\bullet W_{ij}^{(l+1)} \\bullet \\sigma^\\prime(z_j^{(l)})\\tag7$$ 则：$$\\delta^{(l)} = ((W^{(l+1)})^T\\delta^{(l+1)})\\odot\\sigma^\\prime(z^{(l)})\\tag8$$ 损失函数关于权重和偏置的偏导分别为：$$\\frac{\\partial C}{\\partial W_{ij}^{(l)}} = a_i^{(l-1)}\\delta_i^{(l)}\\tag9$$$$\\frac{\\partial C}{\\partial b_{i}^{(l)}} =\\delta_i^{(l)}\\tag{10}$$ 误差根据8式由输出层向后传播，再结合1，2，9，10四式对权重和偏置进行更新 5.实现下面是一个简单3隐层神经网络的实现 In [ ]: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167import numpy as npdef loss(pred, y): return np.sum((pred - y) ** 2)def loss_prime(pred, y): return pred - yclass network: def __init__(self, input_size, hidden_size, num_layers, output_size, loss = loss, loss_prime = loss_prime): self.input_size = input_size self.hidden_size = hidden_size self.num_layers = num_layers self.output_size = output_size # activation function self.activation = self.sigmoid # derivative of activation function self.activation_prime = self.sigmoid_prime # loss funciton self.loss = loss # derivative of loss function self.loss_prime = loss_prime # input-&gt;hidden self.w_ih = np.random.randn(input_size, hidden_size) self.b_ih = np.random.randn(1, hidden_size) # hidden layers self.W_hh = [np.random.randn(hidden_size, hidden_size) for _ in range(num_layers - 1)] self.B_hh = [np.random.randn(1, hidden_size) for _ in range(num_layers - 1)] # hidden-&gt;output self.w_ho = np.random.randn(hidden_size, output_size) self.b_ho = np.random.randn(1, output_size) # assemble w and b self.W = [self.w_ih] self.W.extend(self.W_hh) self.W.append(self.w_ho) self.B = [self.b_ih] self.B.extend(self.B_hh) self.B.append(self.b_ho) # activation def sigmoid(self, x): return 1.0 / (1 + np.exp(-x)) def sigmoid_prime(self, x): return self.sigmoid(x) * (1 - self.sigmoid(x)) # forward pass, calculate the output of the network def forward(self, a): for w, b in zip(self.W, self.B): a = self.activation(np.dot(a, w) + b) return a # backpropagate error def backward(self, x, y): delta_w = [np.zeros(w.shape) for w in self.W] delta_b = [np.zeros(b.shape) for b in self.B] # get output of each layer in forward pass out = x outs = [] zs = [] for w, b in zip(self.W, self.B): z = np.dot(out, w) + b zs.append(z) out = self.activation(z) outs.append(out) # δ of last layer delta = self.loss_prime(outs[-1], y) * self.activation_prime(zs[-1]) delta_b[-1] = delta delta_w[-1] = np.dot(outs[-2].transpose(), delta) for i in range(2, len(delta_w)): delta = np.dot(delta, self.W[-i+1].transpose()) * self.activation_prime(zs[-i]) delta_b[-i] = delta delta_w[-i] = np.dot(outs[-i-1].transpose(), delta) return delta_w, delta_b # update w and b def update(self, batch, lr): delta_w = [np.zeros(w.shape) for w in self.W] delta_b = [np.zeros(b.shape) for b in self.B] for x, y in batch: d_w, d_b = self.backward(x, y) delta_w = [a + b for a, b in zip(delta_w, d_w)] delta_b = [a + b for a, b in zip(delta_b, d_b)] self.W = [w - lr * t for w, t in zip(self.W, delta_w)] self.B = [b - lr * t for b, t in zip(self.B, delta_b)] # SGD training def train(self, train_data, epochs, batch_size, lr): for i in range(epochs): np.random.shuffle(train_data) batches = [train_data[t : t + batch_size] for t in range(0, len(train_data), batch_size)] for batch in batches: self.update(batch, lr) loss = 0 for x, y in train_data: loss += self.loss(self.forward(x), y) loss /= len(train_data) print(\"Epoch %d done, loss: %f\" % (i + 1, loss)) # predict def predict(self, x): return self.forward(x)# use it for handwriting digits classificationimport tensorflow as tfmnist = tf.keras.datasets.mnistdef onehot(y): arr = np.zeros([y.shape[0], 10]) for i in range(y.shape[0]): arr[i][y[i]] = 1 return arr(x_train, y_train),(x_test, y_test) = mnist.load_data()x_train, x_test = x_train / 255.0, x_test / 255.0x_train = x_train.reshape([-1, 28 * 28])x_test = x_test.reshape([-1, 28 * 28])y_train = onehot(y_train)y_test = onehot(y_test)train_data = [t for t in zip(x_train, y_train)]test_data = [t for t in zip(x_test, y_test)]input_size = 28 * 28hidden_size = 100num_layers = 3output_size = 10net = network(input_size, hidden_size, num_layers, output_size)lr = 0.005epochs = 100batch_size = 100net.train(train_data, epochs, batch_size, lr)def softmax(x): exp = np.exp(x) return exp / np.sum(exp)correct = 0for x, y in test_data: ret = net.forward(x) pred = softmax(ret) if np.argmax(pred) == np.argmax(y): correct += 1acc = float(correct) / len(test_data)print('test accuracy: ', acc)","categories":[],"tags":[{"name":"Tech","slug":"Tech","permalink":"https://zjusct.github.io/tags/Tech/"},{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://zjusct.github.io/tags/Machine-Learning/"}],"author":"陈岩"},{"title":"Distributed Tensorflow","slug":"tensorflow","date":"2018-12-23T11:57:25.000Z","updated":"2019-05-31T15:04:27.507Z","comments":true,"path":"2018/12/23/tensorflow/","link":"","permalink":"https://zjusct.github.io/2018/12/23/tensorflow/","excerpt":"","text":"1.单机log_device_placement单机情况比较简单，不需要特殊配置，TensorFlow会自动将计算任务分配到可用的GPU上，在定义session时，可以通过log_device_placement参数来打印具体的计算任务分配： 123456789import tensorflow as tfa = tf.constant([1.0, 2.0, 3.0], shape=[3], name='a')b = tf.constant([1.0, 2.0, 3.0], shape=[3], name='b')c = a + bwith tf.Session(config = tf.ConfigProto(log_device_placement = True)) as sess: sess.run(tf.global_variables_initializer()) print(sess.run(c)) 指定设备如果需要让一些运算在特定的设备上执行，可以使用tf.device: 1234567891011import tensorflow as tfwith tf.device('/cpu:0'): a = tf.constant([1.0, 2.0, 3.0], shape=[3], name='a') b = tf.constant([1.0, 2.0, 3.0], shape=[3], name='b')with tf.device('/gpu:0'): c = a + bwith tf.Session(config = tf.ConfigProto(log_device_placement = True)) as sess: sess.run(tf.global_variables_initializer()) print(sess.run(c)) 环境变量尽管上面一个例子中我们只给CPU和GPU0指定了计算任务，但是两块显卡的显存都被占满了： 因为TensorFlow会默认占满所有可见GPU的显存，对于简单的计算任务，这样显然非常浪费，我们可以通过修改环境变量CUDA_VISIBLE_DEVICES解决这个问题: 12# 运行时指定环境变量CUDA_VISIBLE_DEVICES=0 python demo.py 1234# Python 代码中修改环境变量import osos.environ['CUDA_VISIBLE_DEVICES']='0'... 2.多机In-graph &amp; Between-graphTensorFlow的分布式训练有两种模式：In-graph和Between-graph In-graph: 不同的机器执行计算图的不同部分，和单机多GPU模式类似，一个节点负责模型数据分发，其他节点等待接受任务，通过tf.device(“/job:worker/task:n”)来指定计算运行的节点 Between-graph:每台机器执行相同的计算图 Author: 陈岩PostDate: 2018.12.21","categories":[],"tags":[{"name":"Tech","slug":"Tech","permalink":"https://zjusct.github.io/tags/Tech/"},{"name":"Tensorflow","slug":"Tensorflow","permalink":"https://zjusct.github.io/tags/Tensorflow/"}],"author":"陈岩"},{"title":"Quick Guide to CUDA Profiling","slug":"cuprof","date":"2018-12-07T15:48:33.000Z","updated":"2019-05-31T15:04:27.498Z","comments":true,"path":"2018/12/07/cuprof/","link":"","permalink":"https://zjusct.github.io/2018/12/07/cuprof/","excerpt":"1. Brief Introduction在并行计算领域，很难通过纯理论的分析来确定程序的性能，GPGPU这种基于特定计算架构的计算任务更甚。事实上，很多制约并行算法性能的瓶颈很可能不在算法本身（比如资源调度障碍）。因此，对给定程序进行充分的性能测试与后续分析是相当必要的调优方法。 Nvidia提供了nvprof，nvvp，Nsight三种cuda可用的性能分析工具，本文将简述配合使用nvprof与nvvp的cuda程序性能分析方法。","text":"1. Brief Introduction在并行计算领域，很难通过纯理论的分析来确定程序的性能，GPGPU这种基于特定计算架构的计算任务更甚。事实上，很多制约并行算法性能的瓶颈很可能不在算法本身（比如资源调度障碍）。因此，对给定程序进行充分的性能测试与后续分析是相当必要的调优方法。 Nvidia提供了nvprof，nvvp，Nsight三种cuda可用的性能分析工具，本文将简述配合使用nvprof与nvvp的cuda程序性能分析方法。 2. Check Out Device Properties由于cuda程序的线程/块分配方案与程序运行的的硬件高度相关，故对目标平台的硬件参数有一定程度的了解是相当有必要的。我们可以使用cudaGetDeviceProperties()函数获取设备的各项属性，下述代码可以结合cuda_runtime_api.h#1218处struct cudaDeviceProp的定义和各属性的相应注解自行理解。 12345678int nDevices;cudaDeviceProp prop;cudaGetDeviceCount( &amp;nDevices );for ( auto i = 0; i != nDevices; ++i )&#123; cudaGetDeviceProperties( &amp;prop, i ); // check out interesting property&#125; 3. Profile Using Nvprof3.1. Quick Start1nvprof --help 3.2. Metrics 使用--query-metrics列出所有可测试的性能指标。 使用--metrics sm_efficiency,warp_execution_efficiency,...指定要测试的性能指标。 3.3. PC Sampling在CC5.2或更高的设备上支持使用PC采样(PC sampling)技术。 PC采样技术通过Round-Robin方法对SM中所有活动线程束的PC状态进行采样，采样结果包含如下两种可能： 线程束完成了当前指令。 线程束被stall，不能完成当前指令，并可以给出stall的原因。 事实上线程束被stall并不代表指令流水线处于stall状态，因为其他正常运行的线程束可以利用计算资源。 CC6.0以上的设备对PC采样方法进行了改进，通过检查线程束调度器是否执行指令来确定指令流水线是否真正处于stall状态，从而能正确指示指令stall的原因。 4. Data Visualize Using Nvvpnvvp可以导入nvprof的分析结果，可视化显示统计图表，并且建议性地指出程序可能存在的瓶颈。 以饼状图显示各类stall比重 以频谱显示各类指令比例 通过source file mapping可视化指令stall状态，需要在编译选项中指定-lineinfo 4.1. Usage12nvprof -f --kernels \"kernelName\" --analysis-metrics -o a.nvvp &lt;task&gt; &lt;args&gt;nvvp a.nvvp 这里我使用的方法是在集群上用nvprof做性能测试，之后将分析结果*.nvvp传回本地用nvvp做可视化。 Ext. RemarksTradeoff Between Registers and Threads在实际Profiling中重新认识了这个问题。 在默认情况下，nvcc为每个线程分配maxRegsPerThread个数的寄存器，在Tesla K40上，这个值为64。同时，每个SM持有为65536个寄存器，这意味着单个SM中的线程数最多不超过1024。通过检查参数表，我们发现该设备单个SM可容纳线程数为2048。这意味着我们计算任务的GPU利用率最大只有50%（所有SM均满载的状态下）。 在这种情况下，如果我们将分配给单个线程的寄存器数目减半，则最大GPU利用率可以达到100%。但若发生寄存器溢出（register spilling），溢出的存储空间被放到片外的local memory，访问速度在（同在片外的）global memory级别。 在实际的CUDA核函数中，能全部利用64个寄存器的情况很少。寄存器的使用情况可以在nvvp中检查，如果发现有大量寄存器浪费，可以立即减少寄存器数量。在大多数情况下，可以结合计算任务的量级和性质来调节线程最大寄存器数，从而达到有针对性的性能调优。 在nvcc中指定单个线程最大寄存器数，可以添加编译选项-maxrregcount=N。如果限定不修改编译选项或需要逐核函数指定，则需要使用__launch_bounds__限定符，如下（隐式地指定了最大寄存器个数）： 123456__global__ void__launch_bounds__(maxThreadsPerBlock, minBlocksPerMultiprocessor)MyKernel(...)&#123; ...&#125; 在我的path tracer中对上述方法进行测试，将每线程的寄存器数减半为32，SM线程数加倍并满载，GPU利用率由30+提升到70+，执行速度有1.5倍左右的提升。 Tradeoff Between BlockDim and BlockPerSM当一个块（block）中的所有线程束（warp）全部完成时，这个块才可以被SM调度。如果块的大小过大，则块的运行速度受单个线程束约束的开销就越大（如果算法并行度很高，增大块的大小不失为一个好选择）；如果块的大小过小，则一方面SM可能无法达到其最大利用率（受maxBlocksPerSM的限制），另一方面SM调度块的额外开销也会增大。尤其是针对不同特点的计算任务有不同的更优选择，如divergency较高的任务更适合较小的BlockDim。所以在选择BlockDim时不仅要在算法的适应性上做考虑，还要通过多次性能测试来进行针对性的优化。 Beware of Ladder Effects注意计算资源分配时要注意分配的资源量要能够被组别整除，否则会出现断层状的资源浪费现象。 每块线程数与SM中最大线程束数的关系","categories":[],"tags":[{"name":"Tech","slug":"Tech","permalink":"https://zjusct.github.io/tags/Tech/"},{"name":"CUDA","slug":"CUDA","permalink":"https://zjusct.github.io/tags/CUDA/"},{"name":"Profile","slug":"Profile","permalink":"https://zjusct.github.io/tags/Profile/"}],"author":"小妹妹"},{"title":"CUDA内存管理总结(一)","slug":"cuda","date":"2018-11-24T16:46:08.000Z","updated":"2019-05-31T15:04:27.493Z","comments":true,"path":"2018/11/25/cuda/","link":"","permalink":"https://zjusct.github.io/2018/11/25/cuda/","excerpt":"本文将探讨CUDA中的内存管理机制。","text":"本文将探讨CUDA中的内存管理机制。 一、寄存器​ GPU的每个SM（流多处理器）都有上千个寄存器，每个SM都可以看作是一个多线程的CPU核，但与一般的CPU拥有二、四、六或八个核不同，一个GPU可以有N个SM核；同样，与一般的CPU核支持一到两个硬件线程不同，每个SM核可能有8~192个SP（流处理器），亦即每个SM能同时支持这么多个硬件线程。事实上，一台GPU设备的所有SM中活跃的线程数目通常数以万计。 1.1 寄存器映射方式​ CPU处理多线程：进行上下文切换，使用寄存器重命名机制，将当前所有寄存器的状态保存到栈（系统内存），再从栈中恢复当前需要执行的新线程在上一次的执行状态。这些操作通常花费上百个CPU时钟周期，有效工作吞吐量低。 ​ GPU处理多线程：与CPU相反，GPU利用多线程隐藏了内存获取与指令执行带来的延迟；此外，GPU不再使用寄存器重命名机制，而是尽可能为每个线程分配寄存器，从而上下文切换就变成了寄存器组选择器（或指针）的更新，几乎是零开销。 1.2 寄存器空间大小​ 每个SM可提供的寄存器空间大小分别有8KB、16KB、32KB和64KB，每个线程中的每个变量占用一个寄存器，因而总共会占用N个寄存器，N代表调度的线程数量。当线程块上的寄存器数目是允许的最大值时，每个SM会只处理一个线程块。 1.3 SM调度线程、线程块​ 由于大多数内核对寄存器的需求量很低，所以可以通过降低寄存器的需求量来增加SM上线程块的调度数量，从而提高运行的线程总数，根据线程级并行“占用率越高，程序运行越快”，可以实现运行效率的优化。当线程级并行（Thread-Level Parallelism，TLP）足以隐藏存储延迟时会达到一个临界点，此后想要继续提高程序性能，可以在单个线程中实现指令级的并行（Instruction-Level Parallelism，ILP），即单线程处理多数据。 ​ 但在另一方面，每个SM所能调度的线程总量是有限制的，因此当线程总量达到最大时，再减少寄存器的使用量就无法达到提高占有率的目的（如下表中寄存器数目由20减小为16，线程块调度数量不变），所以在这种情况下，应增加寄存器的使用量到临界值。 1.4 寄存器优化方式​ 1）将中间结果累积在寄存器而非全局内存中。尽量避免全局内存的写操作，因为如果操作聚集到同一块内存上，就会强制硬件对内存的操作序列化，导致严重的性能降低； ​ 2）循环展开。循环一般非常低效，因为它们会产生分支，造成流水线停滞。 1.5 总结​ 使用寄存器可以有效消除内存访问，或提供额外的ILP，以此实现GPU内核函数的加速，这是最为有效的方法之一。 二、共享内存2.1 基本概念​ 1、共享内存实际上是可以受用户控制的一级缓存，每个SM中的一级缓存和共享内存共用一个64KB的内存段。 ​ 2、共享内存的延迟很低，大约有1.5TB/s的带宽，而全局内存仅为160GB/s，换言之，有效利用共享内存有可能获得7倍的加速比。但它的速度依然只有寄存器的十分之一，并且共享内存的速度几乎在所有GPU中都相同，因为它由核时钟频率驱动。 ​ 3、只有当数据重复利用、全局内存合并，或者线程之间有共享数据（例如同时访问相同地址的存储体）的时候使用共享内存才更合适，否则将数据直接从全局内存加载到寄存器性能会更好。 ​ 4、共享内存是基于存储体切换的架构（bank-switched architecture），费米架构的设备上有32个存储体。无论有多少线程发起操作，每个存储体每个周期只执行一次操作。因此，如果线程束中的每个线程各访问一个存储体，那么所有线程的操作都可以在一个周期内同时执行，且所有操作都是独立互不影响的。此外，如果所有线程同时访问同一地址的存储体，会触发一个广播机制到线程束中的每个线程中。但是，如果是其他的访问方式，线程访问共享内存就需要排队，即一个线程访问时，其他线程将阻塞闲置。因此很重要的一点时，应该尽可能地获得零存储体冲突的共享内存访问。 2.2 Example：使用共享内存排序2.2.1 归并排序​ 假设待排序的数据集大小为N，现将数据集进行划分。根据归并排序的划分原则，最后每个数据包中只有两个数值需要排序，因此，在这一阶段，最大并行度可达到 $N \\over 2$ 个独立线程。例如，处理一个大小为512KB的数据集，共有128K个32位的元素，那么最多可以使用的线程个数为64K个（N=128K，N/2=64K），假设GPU上有16个SM，每个SM最多支持1536个线程，那么每个GPU上最多可以支持24K个线程，因此，按照这样划分，64K的数据对只需要2.5次迭代即可完成排序操作。 ​ 但是，如果采用上述划分排序方式再进行合并，我们需要从每个排好序的数据集中读出元素，对于一个64K的集合，需要64K次读操作，即从内存中获取256MB的数据，显然当数据集很大的时候不合适。 ​ 因此，我们采用通过限制对原始问题的迭代次数，通过基于共享内存的分解方式来获得更好的合并方案。因为在费米架构的设备上有32个存储体，即对应32个线程，所以当需要的线程数量减少为32（一个线程束）时，停止迭代，于是共需要线程束4K个（128K/32=4K），又因为GPU上有16个SM，所以这将为每个SM分配到256个线程束。然而由于费米架构设备上的每个SM最多只能同时执行48个线程束，因此多个块将被循环访问。 ​ 通过将数据集以每行32个元素的方式在共享内存中进行分布，每列为一个存储体，即可得到零存储体冲突的内存访问，然后对每一列实施相同的排序算法。（或者也可以理解为桶排序呀） ​ 然后再进行列表的合并。 2.2.2 合并列表​ 先从串行合并任意数目的有序列表看起： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546void merge_array(const u32 *const src_array, //待排序数组 u32 *const dest_array, //排序后的数组 const u32 num_lists, //列表总数 const u32 num_elements) //数据总数&#123; const u32 num_elements_per_list = (num_elements / num_lists);//每个列表中的数据个数 u32 list_indexes[MAX_NUM_LISTS]; //所有列表当前所在的元素下标 for(u32 list = 0; list &lt; num_lists; list++) &#123; list_indexes[list] = 0; &#125; for(u32 i = 0; i&lt;num_elements; i++) &#123; dest_array[i] = find_min(scr_array, list_indexes, num_lists, num_elements_per_list); &#125;&#125;u32 find_min(const u32*cosnt src_array, u32 *const list_indexes, const u32 num_lists, const u32 num_elements_per_list)//寻找num_lists个元素中的最小值&#123; u32 min_val = 0xFFFFFFFF; u32 min_idx = 0; for(u32 i = 0; i &lt; num_lists; i++) &#123; if(list_indexes[i] &lt; num_elements_per_list) &#123; const u32 src_idx = i + (list_indexes[i]*num_lists); const u32 data = src_array[src_idx]; if(data &lt;= min_val) &#123; min_val = data; min_idx = i; &#125; &#125; &#125; list_indexes[min_idx]++; return min_val;&#125; ​ 将上述算法用GPU实现 123456789101112__global__ void gpu_sort_array_array(u32 *const data, const u32 num_lists, const u32 num_elements)&#123; const u32 tid = (blockIdx.x * blockDim.x) + threadIdx.x; __shared__ u32 sort_tmp[NUM_ELEM]; __shared__ u32 sort_tmp_1[NUM_ELEM]; copy_data_to_shared(data, sort_tmp, num_lists, num_elements, tid); radix_sort2(sort_tmp, num_lists, num_elements, tid, sort_tmp_1); merge_array6(sort_tmp, data, num_lists, num_elements, tid);&#125; ​ 第一个函数的实现： 123456789101112__device__ void copy_data_to_shared(const u32 *const data, u32 *sort_tmp, const u32 num_lists, const u32 num_elements, const u32 tid)&#123; for(u32 i = 0; i &lt; num_elements; i++) &#123; sort_tmp[i+tid] = data[i+tid]; &#125; __syncthreads();&#125; ​ 该函数中，程序按行将数据从全局内存读入共享内存。当函数调用一个子函数并传入参数时，这些参数必须以某种方式提供给被调用的函数，有两种方法可以采用。一种是通过寄存器传递所需的值，另一种方法是创建一个名为“栈帧”的内存区，但这种方法非常地不高效。出于这一原因，我们需要重新修改合并的程序(merge_array)，以避免函数调用，修改后程序如下（单线程）： 1234567891011121314151617181920212223242526272829303132333435363738__device__ void merge_array1(const u32 *const src_array, u32 *const dest_array, const u32 num_lists, const u32 num_elements, const u32 tid)&#123; __shared__ u32 list_indexes[MAX_NUM_LISTS]; lists_indexes[tid] = 0;//从每个列表的第一个元素开始 __syncthreads(); //单线程 if(tid == 0) &#123; const u32 num_elements_per_list = (num_elements / num_lists); for(u32 i = 0; i &lt; num_elements; i++) &#123; u32 min_val = 0xFFFFFFFF; u32 min_idx = 0; for(u32 list = 0; list &lt; num_lists; list++) &#123; if(list_indexes[list] &lt; num_elements_per_list) &#123; const u32 src_idx = i + (list_indexes[i]*num_lists); const u32 data = src_array[src_idx]; if(data &lt;= min_val) &#123; min_val = data; min_idx = i; &#125; &#125; &#125; list_indexes[min_idx]++; dest_array[i]=min_val; &#125; &#125;&#125; ​ 这里只用一个线程进行合并，但显然，为了获得更好的性能，一个线程是远远不够的。因为数据被写到一个单一的列表中，所以多个线程必须进行某种形式的合作。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162__device__ void merge_array6(const u32 *const src_array, u32 *const dest_array, const u32 num_lists, const u32 num_elements, const u32 tid)&#123; //每个列表分到的元素个数 const u32 num_elements_per_list = (num_elements / num_lists); //创建一个共享列表数组，用来储存当前线程所访问的列表元素下标 __shared__ u32 list_indexes[MAX_NUM_LISTS]; list_indexes[tid] = 0; //创建所有线程共享的最小值与最小值线程号 __shared__ u32 min_val; __shared__ u32 min_tid; __syncthreads(); for(u32 i=0; i&lt;num_elements; i++) &#123; u32 data; //如果当前列表还未被读完，则从中读取数据 if(list_indexes[tid] &lt; num_elements_per_list); &#123; //计算出当前元素在原数组中的下标 const u32 src_idx = tid + (list_indexes[tid] * num_lists); data = src_array[src_idx]; &#125; else &#123; data = 0xFFFFFFFF; &#125; //用零号线程来初始化最小值与最小值线程号 if(tid == 0) &#123; min_val = 0xFFFFFFFF; min_tid = 0xFFFFFFFF; &#125; __syncthreads(); //让所有线程都尝试将它们现在手上有的值写入min_val，但只有最小的数据会被保留 //利用__syncthreads()确保每个线程都执行了该操作 atomicMin(&amp;min_val, data); __syncthreads(); //在所有data==min_val的线程中，选取最小线程号写入min_tid if(min_val == data) &#123; atomicMin(&amp;min_tid, tid); &#125; __syncthreads(); //将满足要求的线程所在列表的当前元素往后移一位，进行下一轮比较 //并将筛选结果存入结果数组dest_array if(tid == min_tid) &#123; list_indexes[tid]++; dest_array[i] = data; &#125; &#125;&#125; ​ 上面的函数中将num_lists个线程进行合并操作，但只用了一个线程一次将结果写入结果数据数组中，保证了结果的正确性，不会引起线程间的冲突。 ​ 其中使用到了 atomicMin 函数。每个线程以从列表中获取的数据作为入参调用该函数，取代了原先单线程访问列表中所有元素并找出最小值的操作。当每个线程调用 atomicMin 函数时，线程读取保存在共享内存中的最小值并于当前线程中的值进行比较，然后把比较结果重新写回最小值对应的共享内存中，同时更新最小值对应的线程号。然而，由于列表中的数据可能会重复，因此可能出现多个线程的值均为最小值的情况，保留的线程号却各不相同。因此需要执行第二步操作，保证保留的线程号为最小线程号。 ​ 虽然这种方法的优化效果很显著，但它也有一定的劣势。例如，atomicMin函数只能用在计算能力为1.2以上的设备上；另外，aotomicMin函数只支持整数型运算，但现实世界中的问题通常是基于浮点运算的，因此在这种情况下，我们需要寻找新的解决方法。 2.2.3 并行归约​ 并行归约适用于许多问题，求最小值只是其中的一种。它使用数据集元素数量一半的线程，每个线程将当前线程对应的元素与另一个元素进行比较，计算两者之间的最小值，并将得到的最小值移到前面。每进行一次比较，线程数减少一半，如此反复直到只剩一个元素为止，这个元素就是需要的最小值。 ​ 在选择比较元素的时候，应该尽量避免选择同一个线程束中的元素进行比较，因为这会明显地导致线程束内产生分支，而每个分支都将使SM做双倍的工作，继而影响程序的性能。因此我们选择将线程束中的元素与另一半数据集中的元素进行比较。如下图，阴影部分表示当前活跃的线程。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071__device__ void merge_array5(const u32 *const src_array, u32 *const dest_array, const u32 num_lists, const u32 num_elements, const u32 tid)&#123; const u32 num_elements_per_list = (num_elements / num_lists); __shared__ u32 list_indexes[MAX_NUM_LISTS]; __shared__ u32 reduction_val[MAX_NUM_LISTS]; __shared__ u32 reduction_idx[MAX_NUM_LISTS]; list_indexes[tid] = 0; reduction_val[tid] = 0; reduction_idx[tid] = 0; __syncthreads(); for(u32 i=0; i&lt;num_elements; i++) &#123; u32 tid_max = num_lists &gt;&gt; 1;//最大线程数为列表总数的一半 u32 data;//使用寄存器可以提高运行效率，将对共享内存的写操作次数减少为1 //当列表中还有未处理完的元素时 if(list_indexes[tid] &lt; num_elements_per_list) &#123; //计算该元素在原数组中的位置 cosnst u32 src_idx = tid + (list_indexes[tid] * num_lists); data = src_array[src_idx]; &#125; //若当前列表已经处理完，将data赋值最大 else &#123; data = 0xFFFFFFFF; &#125; //将当前元素及线程号写入共享内存 reduction_val[tid] = data; reduction_idx[tid] = tid; __syncthreads; //当前活跃的线程数多于一个时 while(tid_max!=0) &#123; if(tid &lt; tid_max) &#123; //将当前线程中的元素与另一半数据集中的对应元素进行比较 const u32 val2_idx = tid + tid_max; const u32 val2 = reduction_val[val2_idx]; //最后保留较小的那个元素 if(reduction_val[tid] &gt; val2) &#123; reduction_val[tid] = val2; reduction_idx[tid] = reduction_idx[val_idx]; &#125; &#125; //线程数减半，进入下一轮循环 tid_max &gt;&gt;= 1; __syncthreads(); &#125; //在零号线程中将结果写入结果数组，并将相应线程所指的元素后移一位 if(tid == 0) &#123; list_indexes[reduction_idx[0]]++; dest_array[i] = reduction_val[0]; &#125; __syncthreads(); &#125;&#125; ​ 同样，这种方法也在共享内存中创建了一个临时的列表 list_indexes 用来保存每次循环中从 num_list 个数据集列表中选取出来进行比较的数据。如果进行合并的列表已经为空，那么就将临时列表中的对应数据区赋最大值0xFFFFFFFF。而每轮while循环后，活跃的线程数都将减少一半，直到最后只剩一个活跃的线程，亦即零号线程。最后将结果复制到结果数组中并将最小值所对应的列表索引加一，以确保元素不会被处理两次。 2.2.4 混合算法​ 在了解atomicMin函数和并行归约两种方案后，我们可以利用这两种算法各自的优点，创造出一种新的混合方案。 ​ 简单的1~N个数据归约的一个主要问题就是当N增大时，程序的速度先变快再变慢，达到最高效的情形时N在8至16左右。混合算法将原数据集划分成诸多个小的数据集，分别寻找每块中的最小值，然后再将每块得到的结果最终归约到一个值中。这种方法和并行归约的思想非常相似，但同时又省略了并行归约中的多次迭代。代码更新如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#define REDUCTION_SIZE 8#define REDUCTION_SIZE_BIT_SHIFT 3#define MAX_ACTIVE_REDUCTIONS ((MAX_NUM_LISTS) / (REDUCTION_SIZE))__device__ void merge_array(const u32 *const src_array, u32 *const dest_array, const u32 num_lists, const u32 num_elements, const u32 tid)&#123; //每个线程都从原数组中读入一个数据，用作首次比较 u32 data = src_array[tid]; //当前线程所在的数据块编号（8个线程为一组，每个线程处理一个列表） const u32 s_idx = tid &gt;&gt; REDUCTION_SIZE_BIT_SHIFT; //首次进行分别归约的数据块总数 const u32 num_reductions = num_lists &gt;&gt; REDUCTION_SIZE_BIT_SHIFT; const u32 num_elements_per_list = num_elements / num_lists; //在共享内存中创建一个列表，指向每个线程当前所在的元素，并初始化为0 __shared__ u32 list_indexes[MAX_NUM_LISTS]; list_indexes[tid] = 0; //遍历所有数据 for(u32 i=0; i&lt;num_elements; i++) &#123; //每个数据块在内部归约后都会产生一个相应的最小值 //在共享内存中开辟一个列表，用来保存每组的最小值 __shared__ u32 min_val[MAX_ACTIVE_REDUCTIONS]; __shared__ u32 min_tid; //初始化每个数据块的内部最小值 if(tid &lt; num_lists) &#123; min_val[s_idx] = 0xFFFFFFFF; min_tid = 0xFFFFFFFF; &#125; __syncthreads(); //将当前线程的数据与所处数据块的最小值进行比较，并保留较小的那一个 atomicMin(&amp;min_val[s_idx], data); //进行归约的数据块总数不为零时 if(num_reductions &gt; 0) &#123; //确保每个线程都已经将上一步比较操作完成 __syncthreads(); //将每个数据块产生的最小值与零号数据块的最小值进行比较，保留较小的那一个 if(tid &lt; num_reductions) &#123; atomicMin(&amp;min_val[0], min_val[tid]); __syncthreads(); &#125; //如果当前线程的数据等于此次比较保留的最小值，记录最小线程号 if(data == min_val[0]) &#123; atomicMin(&amp;min_tid, tid); &#125; //确保上一步操作每个线程都已经完成，才能执行下一句 __syncthreads(); //如果当前线程号恰为记录下的最小线程号 if(tid == min_tid) &#123; //当前所指元素后移一位 list_indexes[tid]++; //将结果保存入结果数组 dest_array[i] = data; //若该线程对应的列表尚未被处理完 if(list_indexes[tid] &lt; num_elements_per_list) //更新该线程的data，进行下一轮比较 data = src_array[tid + (list_indexes[tid] * num_lists)]; else data = 0xFFFFFFFF; &#125; __syncthreads(); &#125; &#125;&#125; ​ 注意到： ​ 1）原来的min_val由单一的数据扩展成为一个共享数据的数组，这是因为每个独立的线程都需要从它对应的数据集中获取当前的最小值来进行内部比较。每个最小值都是一个32位的数值，因此可以存储在独立的共享内存存储体中。 ​ 2）内核函数中的REDUCTION_SIZE的值被设置成8，意味着每个数据块中包含8个数据，程序分别找出每个数据块的最小值，然后再在这些最小值中寻找最终的最小值。 ​ 3）内核函数中最重要的一个变化是，只有每次比较的最小值所对应的那个线程的data才会更新，其他线程的data都不会更新。而在之前的内核函数中，每轮比较开始，所有线程都会从对应的列表中重新读入data 的值，随着N的增大，这将变得越来越低效。 2.2.5 总结​ 1）共享内存允许同一个线程块中的线程读写同一段内存，但线程看不到也无法修改其他线程块的共享内存。 ​ 2）共享内存的缓冲区驻留在物理GPU上，所以访问时的延迟远低于访问普通缓冲区的延迟，因此除了使用寄存器，还应更有效地使用共享内存，尤其当数据有重复利用，或全局内存合并，或线程间有共享数据的时候。 ​ 3）编写代码时，将关键字_shared__添加到声明中，使得该变量留驻在共享内存中，并且线程块中的每个线程都可以共享这块内存，使得一个线程块中的多个线程能够在计算上进行通信和协作。 ​ 4）调用 __syncthreads() 函数来实现线程的同步操作，尤其要注意确保在读取共享内存之前，想要写入的操作都已经完成。另外还需要注意，切不可将这个函数放置在发散分支（某些线程需要执行，而其他线程不需要执行），因为除非线程块中的每个线程都执行了该函数，没有任何线程能够执行之后的指令，从而导致死锁。 ​ 5）不妨尝试使用共享内存实现矩阵乘法的优化。 Author: 潘薇鸿PostDate: 2018.11.25","categories":[],"tags":[{"name":"Tech","slug":"Tech","permalink":"https://zjusct.github.io/tags/Tech/"},{"name":"CUDA","slug":"CUDA","permalink":"https://zjusct.github.io/tags/CUDA/"}],"author":"潘薇鸿"},{"title":"浙江大学超算队博客...活了？","slug":"first","date":"2018-09-30T13:25:55.000Z","updated":"2019-05-31T15:04:27.505Z","comments":true,"path":"2018/09/30/first/","link":"","permalink":"https://zjusct.github.io/2018/09/30/first/","excerpt":"写在前面这里是浙江大学超算队的官方博客","text":"写在前面这里是浙江大学超算队的官方博客 记录一些前沿的Tech姿势、大家平时的DeBug经历、还有ASC世界超算大赛的经验分享！ 希望这个博客不仅仅是给以后的小盆友们提供宝贵的经验 更是诸君技术的记录与提升的大好机会 平时我们写着代码 总是不愿意写文档 遇到了非常Tricky又神奇的Bug 花了一下午终于解决了 却没有记录下来 很有可能很多的无谓的时间就会在以后被重复 这样的时间浪费 我们完全可以节省下来！ 希望大家能享受在超算队一起学习的时光~ 从现在开始 把这段美好的时间变成字符 记录下来叭~~ Author: TTfishPostDate: 2018.9.30","categories":[],"tags":[{"name":"Tech","slug":"Tech","permalink":"https://zjusct.github.io/tags/Tech/"},{"name":"Spc","slug":"Spc","permalink":"https://zjusct.github.io/tags/Spc/"},{"name":"ZJU","slug":"ZJU","permalink":"https://zjusct.github.io/tags/ZJU/"}],"author":"TTfish"}]}